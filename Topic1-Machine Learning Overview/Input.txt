Setting up Python Instructions for downloading and installing the Anaconda distribution of Python 3. The first task is to install the Anaconda distribution of Python. Anaconda makes it much easier to control all the different editors and packages that you need. It provides the data science libraries that make it possible to complete the Assessments. Windows 10: Download with text instructions Install Anaconda Python, Jupyter Notebook And Spyder video instructions Mac: Download with text instructions How To Python Install on Mac OS Sierra Simplified with Anaconda video instructions Other platforms: Download with text guides at Anaconda Jupyter Notebook To start coding, open Anaconda and then open or launch Jupyter Notebook. This will open a kernel and a shell to work in. The kernel does the hard work but you can use the shell to write and run your Python programs. This Jupyter Notebook video has a repeat of the Anaconda install instructions but the link will take you to the instructions on using a command line to open the Jupyter Notebook and offers a run-through of the environment. Activity Download and install the Anaconda distribution of Python on your own machine. Open Anaconda Navigator to open the Navigator. From the Navigator, open Jupyter Notebook. Python modules and packages Like many other programming languages, Python allows you to store your useful function definitions in a file. You can then import it as a module in your current program. In the following example, we have written bunch of useful Python functions in myfunctions.py. Later we can import this file in the main code. Specific functions such as func1 can now be called using the name of the specific function. Let’s consider a more complex situation. In this example, the module game contains the following structure: You could import all the modules into your program by using the following: import game After this, individual modules can be referenced in the following manner: game.sound.load.func1() game.level.start.func2() An alternative way to import all modules into the program is shown below. from game import * But, if you only want to import all the modules in a specific package, you can use: from game.level import * Importing only a specific module can be done as shown below: from game.level import load In this unit, we will use the following packages which contain popular functions and algorithms: Activity Research one of these packages on line. What is its strength and where would you use it? Matrix addition and subtraction In the previous topic, you setup your Python environment and started creating vectors and matrices. This topic is about matrix operations and how they can be implemented in Python using the NumPy library. Adding or subtracting a scalar value to a matrix Consider a small matrix A{"version":"1.1","math":"\(A\)"}, of dimension 2×2{"version":"1.1","math":"\(2\times 2\)"} .  In other words a matrix which contains two (2) rows ×{"version":"1.1","math":"\(\times\)"} two (2) columns. Let A=[a11a12a21a22]{"version":"1.1","math":"\(A=\begin{bmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \end{bmatrix}\)"}. Consider adding a scalar value (e.g. 3) to the matrix A{"version":"1.1","math":"\(A\)"}. A+3=[a11a12a21a22]+3=[a11+3a12+3a21+3a22+3]{"version":"1.1","math":"A+3=\begin{bmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \end{bmatrix}+3 =\begin{bmatrix} a_{11}+3 & a_{12}+3 \\ a_{21}+3 & a_{22}+3 \end{bmatrix}"} The same basic principle holds true for A−3{"version":"1.1","math":"\(A-3\)"}. A−3=[a11a12a21a22]−3=[a11−3a12−3a21−3a22−3]{"version":"1.1","math":"A-3=\begin{bmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \end{bmatrix}-3 =\begin{bmatrix} a_{11}-3 & a_{12}-3 \\ a_{21}-3 & a_{22}-3 \end{bmatrix}"} Notice that we add (or subtract) the scalar value to each element in the matrix A{"version":"1.1","math":"\(A\)"}.  The matrix can be of any dimension. A = np.array([(1,2),(3,4)]) print("Before matrix adding") print(A) print("After matrix adding with 3") print(A+3) Before matrix adding [[1 2]  [3 4]] After matrix adding with 3 [[4 5]  [6 7]] Adding or subtracting two matrices Consider two matricesA=[a11a12a21a22]{"version":"1.1","math":"\(A=\begin{bmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \end{bmatrix}\)"} and B=[b11b12b21b22]{"version":"1.1","math":"\(B=\begin{bmatrix} b_{11} & b_{12} \\ b_{21} & b_{22} \end{bmatrix}\)"}.  To find the result of A−B{"version":"1.1","math":"\(A-B\)"} , simply subtract each element of A{"version":"1.1","math":"\(A\)"} with the corresponding element of B{"version":"1.1","math":"\(B\)"}: A−B=[a11a12a21a22]−[b11b12b21b22]=[a11−b11a12−b12a21−b21a22−b22]{"version":"1.1","math":"A -B = \begin{bmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \end{bmatrix} - \begin{bmatrix} b_{11} & b_{12} \\ b_{21} & b_{22} \end{bmatrix} = \begin{bmatrix} a_{11}-b_{11} & a_{12}-b_{12} \\ a_{21}-b_{21} & a_{22}-b_{22} \end{bmatrix}"} Addition works exactly the same way: A+B=[a11a12a21a22]+[b11b12b21b22]=[a11+b11a12+b12a21+b21a22+b22]{"version":"1.1","math":"\(A + B = \begin{bmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \end{bmatrix} + \begin{bmatrix} b_{11} & b_{12} \\ b_{21} & b_{22} \end{bmatrix} = \begin{bmatrix} a_{11}+b_{11} & a_{12}+b_{12} \\ a_{21}+b_{21} & a_{22}+b_{22} \end{bmatrix}\)"} An important point to know about matrix addition and subtraction is that it is only defined when A{"version":"1.1","math":"\(A\)"} and B{"version":"1.1","math":"\(B\)"} are of the same size. Here, both are 2×2{"version":"1.1","math":"\(2 \times 2\)"}.  Since operations are performed element by element, these two matrices must be conformable; and for addition and subtraction that means they must have the same numbers of rows and columns. It helps to be explicit about the dimensions of matrices for checking conformability. Writing the equations in the following manner helps: A2×2+B2×2=[a11+b11a12+b12a21+b21a22+b22]2×2{"version":"1.1","math":"A_{2 \times 2} + B_{2 \times 2}= \begin{bmatrix} a_{11}+b_{11} & a_{12}+b_{12} \\ a_{21}+b_{21} & a_{22}+b_{22} \end{bmatrix}_{2 \times 2}"} Notice that the result of a matrix addition or subtraction operation is always of the same dimension as the two operands. Code example 2 Let’s see how this is done in Python. Let’s define another matrix, B{"version":"1.1","math":"\(B\)"} that is also 2×2{"version":"1.1","math":"\(2\times 2\)"} and add to A{"version":"1.1","math":"\(A\)"}. A = np.identity(2) B = np.random.randn(2,2) print(B) As matrix B{"version":"1.1","math":"\(B\)"} contains random elements, your output may be different to what is displayed below: [[-0.53202029 -0.67608684] [-0.31786067  0.90893483]] Let’s add the two matrices together and see what the result looks like. result = A + B result Again, your output may be different to what is displayed below. But it should be a matrix of size 2×2{"version":"1.1","math":"\(2\times 2\)"}.  array([[ 0.46797971, -0.67608684], [-0.31786067,  1.90893483]]) Activity Make sure that you have experimented with all the individual Python coding examples in this lesson and that you are confident in how to code these basic matrix operations. Using the NumPy Package You have already explored the basics of using the NumPy library. Let’s extend this to create vectors and matrices and then perform some common linear algebra operations on these data. Before we start, let’s setup our Python environment. Copy the code and run it. We can import our packages and then, add them to our python environment. We will use two main libraries: NumPy - for vectors, matrices, random numbers, and linear algebra functions matplotlib - for plotting Code example 1 We do that with the following Python code: Import python library import numpy as np import pandas as pd import matplotlib.pyplot as plt Code example 2 Let’s create a vector and a matrix. We use np.array function to create a vector/array from a list of numbers: x = np.array([1,2,3]) print('An example of vector is:') print(x) A = np.array([(1,2),(3,4)]) print('An example of matrix is:') print(A) The output will look like this: A = np.zeros([3,3]) print('An example of all zero matrix is:') print(A) A = np.ones([3,3]) print('An example of all one matrix is:') print(A) A = np.identity(3) print('An example of an identity matrix is:') print(A) This outputs the following. As you can see, the NumPy library can help automate the creation of specific types of matrices. An example of all zero matrix is: [[0. 0. 0.] [0. 0. 0.] [0. 0. 0.]] An example of all one matrix is: [[1. 1. 1.] [1. 1. 1.] [1. 1. 1.]] An example of an identity matrix is: [[1. 0. 0.] [0. 1. 0.] [0. 0. 1.]] You can also create a matrix with random numbers if needed. B = np.random.randn(4,3) print('An example of a random matrix is:') print(B) Here’s what the output may look like. As its a matrix with random numbers your individual elements may be different to what’s given below: An example of a random matrix is: [[ 1.10808491 -0.57351362  1.64344163]  [ 0.16306238 -0.57848446  1.34708602]  [ 0.57971464  0.59613719 -0.94570683]  [ 1.3847897  -1.91214193 -0.05571648]] Activity Make sure that you have experimented with all the individual Python coding examples that we have in this lesson, and that you are confident in how NumPy works. Matrix multiplication In the previous topic you explored some basic matrix operations and implemented them in Python. In this topic we extend it further to include more advanced operations on matrices. Multiplying a scalar value times a matrix Suppose we want to multiply A=[a11a12a21a22]{"version":"1.1","math":"\(A=\begin{bmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \end{bmatrix}\)"} times a scalar value (e.g. 3) 3×A=3×[a11a12a21a22]=[3a113a123a213a22]{"version":"1.1","math":"3 \times A = 3 \times \begin{bmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \end{bmatrix} = \begin{bmatrix} 3a_{11} & 3a_{12} \\ 3a_{21} & 3a_{22} \end{bmatrix}"} The resultant matrix is of dimension (2,2). Scalar multiplication is commutative, so that 3×A=A×3{"version":"1.1","math":"\(3 \times A = A \times 3\)"} Notice that the product is defined for a matrix A{"version":"1.1","math":"\(A\)"} of any dimension. Code example #1 Similar to scalar addition and subtraction, the code is simple: A * 3 The output looks like this: array([[3., 0.],   [0., 3.]]) Multiplying two matrices Lets start simply: consider the 2×1{"version":"1.1","math":"\(2 \times 1\)"} vector  C=[c11c21]{"version":"1.1","math":"\(C= \begin{bmatrix} c_{11} \\ c_{21} \end{bmatrix}\)"}. Consider multiplying matrix A2×2{"version":"1.1","math":"\(A_{2 \times 2}\)"} with the vector C2×1{"version":"1.1","math":"\(C_{2 \times 1}\)"}.   Unlike the addition and subtraction case, this product is defined. Here, conformability depends not on the row and column dimensions, but rather on the column dimensions of the first operand and the row dimensions of the second operand. We can write this operation as follows: A2×2×C2×1=[a11a12a21a22]2×2×[c11c21]2×1=[a11c11+a12c21a21c11+a22c21]2×1{"version":"1.1","math":"A_{2 \times 2} \times C_{2 \times 1} = \begin{bmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \end{bmatrix}_{2 \times 2} \times \begin{bmatrix} c_{11} \\ c_{21} \end{bmatrix}_{2 \times 1} = \begin{bmatrix} a_{11}c_{11} + a_{12}c_{21} \\ a_{21}c_{11} + a_{22}c_{21} \end{bmatrix}_{2 \times 1}"} Let’s extend this now to two matrices. Matrix C is of dimension 2×3{"version":"1.1","math":"\(2 \times 3\)"} and matrix A{"version":"1.1","math":"\(A\)"} is of dimension 3×2{"version":"1.1","math":"\(3 \times 2\)"}.  A3×2=[a11a12a21a22a31a32]3×2,C2×3=[c11c12c13c21c22c23]2×3{"version":"1.1","math":"\(A_{3 \times 2}=\begin{bmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \\ a_{31} & a_{32} \end{bmatrix}_{3 \times 2} , C_{2 \times 3} = \begin{bmatrix} c_{11} & c_{12} & c_{13} \\ c_{21} & c_{22} & c_{23} \\ \end{bmatrix}_{2 \times 3}\)"} Here, A×C{"version":"1.1","math":"\(A \times C\)"} is:  A3×2×C2×3=[a11a12a21a22a31a32]3×2×[c11c12c13c21c22c23]2×3{"version":"1.1","math":"A_{3 \times 2} \times C_{2 \times 3}= \begin{bmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \\ a_{31} & a_{32} \end{bmatrix}_{3 \times 2} \times \begin{bmatrix} c_{11} & c_{12} & c_{13} \\ c_{21} & c_{22} & c_{23} \end{bmatrix}_{2 \times 3}"} [a11c11+a12c21a11c12+a12c22a11c13+a12c23a21c11+a22c21a21c12+a22c22a21c13+a22c23a31c11+a32c21a31c12+a32c22a31c13+a32c23]3×3{"version":"1.1","math":"\begin{bmatrix} a_{11} c_{11}+a_{12} c_{21} & a_{11} c_{12}+a_{12} c_{22} & a_{11} c_{13}+a_{12} c_{23} \\ a_{21} c_{11}+a_{22} c_{21} & a_{21} c_{12}+a_{22} c_{22} & a_{21} c_{13}+a_{22} c_{23} \\ a_{31} c_{11}+a_{32} c_{21} & a_{31} c_{12}+a_{32} c_{22} & a_{31} c_{13}+a_{32} c_{23} \end{bmatrix}_{3 \times 3}"} So in general, when multiplying two matrices Xrx×cx×Yry×cy{"version":"1.1","math":"\(X_{r_x \times c_x} \times Y_{r_y \times c_y}\)"} we have to remember: For conformability in matrix multiplication,  cx=ry{"version":"1.1","math":"\(c_x=r_y\)"}  or the columns in the first operand must be equal to the rows of the second operand. The result will be of dimension rx×cy{"version":"1.1","math":"\(r_x \times c_y\)"} or of dimensions equal to the rows of the first operand and columns of the second operand. Given these facts, you should convince yourself that matrix multiplication is not generally commutative, that the relationship X×Y=Y×X{"version":"1.1","math":"\(X \times Y = Y \times X\)"}does not hold in all cases. For this reason, we will always be very explicit about whether we are pre-multiplying  X×Y{"version":"1.1","math":"\(X \times Y\)"} or post multiplying Y×X{"version":"1.1","math":"\(Y \times X\)"} the vectors/matrices X{"version":"1.1","math":"\(X\)"} and Y{"version":"1.1","math":"\(Y\)"}. You can find more information matrix multiplication if you need to remind yourself of this maths. Code example 2 The following is an example on how we can implement this in Python using the NumPy library: # Let's redefine A and C to demonstrate matrix multiplication: A = np.random.randn(4,3) C = np.random.randn(3,2) print(np.shape(A)) print(np.shape(C)) This outputs the following: (4, 3) (3, 2) We can use the NumPy dot operator to perform the matrix multiplication. It can be used it two ways to yield the same result: print(A.dot(C)) print('=======') print(np.dot(A,C)) As you can see, both methods result in the same output: [[-1.45867168 -0.39216622]   [ 0.96523102 -0.74885973]   [-2.47869925  1.55953449]   [-0.68863746 -1.17511628]]   =======   [[-1.45867168 -0.39216622]   [ 0.96523102 -0.74885973]   [-2.47869925  1.55953449]   [-0.68863746 -1.17511628]] Code example 3 Suppose instead of pre-multiplying C{"version":"1.1","math":"\(C\)"} by A{"version":"1.1","math":"\(A\)"},  we post-multiply. The product doesn’t exist because we don’t have conformability as described previously. C.dot(A) This results in this error: --------------------------------------------------------------------------   ValueError                               Traceback (most recent call last)   <ipython-input-15-7880d3ab9905> in <module>()   ----&gt; 1 C.dot(A)   ValueError: shapes (3,2) and (4,3) not aligned: 2 (dim 1) != 4 (dim 0)</module></ipython-input-15-7880d3ab9905> Activity Make sure that you have experimented with all the individual Python coding examples in this lesson, and that you are confident in how to code these matrix operations. We will extend the concepts and programming concepts covered in this lesson in the next topic. Matrix division The term matrix division is actually a misnomer. In matrix algebra dividing a matrix is actually the process of inverting the matrix. It is much easier to understand this if we consider the division of scalars. Suppose we want to divide the scalar f{"version":"1.1","math":"\(f\)"} by g{"version":"1.1","math":"\(g\)"}.  We could do this in two different ways: fg=f×g−1.{"version":"1.1","math":"\frac{f}{g}=f \times g^{-1}."} In a scalar setting, these are equivalent ways of solving the division problem. The second one requires two steps: first we invert  g{"version":"1.1","math":"\(g\)"} next we multiply f×{"version":"1.1","math":"\(f \times\)"} the inverted g{"version":"1.1","math":"\(g\)"}. In a matrix world, we need to think about this second approach. first we have to invert the matrix g{"version":"1.1","math":"\(g\)"} and next we will need to pre or post multiply depending on the exact situation we encounter (this is intended to be vague for now). Inverting a matrix As before, consider the square 2×2{"version":"1.1","math":"\(2 \times 2\)"} matrix A=[a11a12a21a22]{"version":"1.1","math":"\(A=\begin{bmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \end{bmatrix}\)"}.  Let the inverse of matrix A{"version":"1.1","math":"\(A\)"} (denoted as A−1{"version":"1.1","math":"\(A^{-1}\)"} be: A−1=[a11a12a21a22]−1=1a11a22−a12a21[a22−a12−a21a11]{"version":"1.1","math":"A^{-1}=\begin{bmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \end{bmatrix}^{-1}=\frac{1}{a_{11}a_{22}-a_{12}a_{21}} \begin{bmatrix} a_{22} & -a_{12} \\ -a_{21} & a_{11} \end{bmatrix}"} The inverted matrix A−1{"version":"1.1","math":"\(A^{-1}\)"} has a useful property: A×A−1=A−1×A=I{"version":"1.1","math":"\(A \times A^{-1}=A^{-1} \times A=I\)"} where I{"version":"1.1","math":"\(I\)"} the identity matrix (the matrix equivalent of the scalar value 1{"version":"1.1","math":"\(1\)"}), is I2×2=[1001]{"version":"1.1","math":"\(I_{2 \times 2}=\begin{bmatrix} 1 & 0 \\ 0 & 1 \end{bmatrix}\)"} furthermore, A×I=A{"version":"1.1","math":"\(A \times I = A\)"} and I×A=A{"version":"1.1","math":"\(I \times A = A\)"}.  An important feature about matrix inversion is that it is undefined if a11a22−a12a21=0{"version":"1.1","math":"\(a_{11}a_{22}-a_{12}a_{21}=0\)"} (in the 2×{"version":"1.1","math":"\(2 \times\)"} case). If this relationship is equal to zero the inverse of A does not exist. If this term is very close to zero, an inverse may exist but A−1{"version":"1.1","math":"\(A^{-1}\)"} may be poorly conditioned, meaning it is prone to rounding error and is likely not well identified computationally. The term a11a22−a12a21{"version":"1.1","math":"\(a_{11}a_{22}-a_{12}a_{21}\)"} is the determinant of matrix A{"version":"1.1","math":"\(A\)"}. For square matrices of size greater than 2×2{"version":"1.1","math":"\(2 \times 2\)"},  if the determinant is equal to zero it indicates that you have a problem with your data matrix (columns are linearly dependent on other columns). The inverse of matrix A{"version":"1.1","math":"\(A\)"} exists if A{"version":"1.1","math":"\(A\)"} is square and is of full rank (i.e. the columns of A{"version":"1.1","math":"\(A\)"} are not linear combinations of other columns of A{"version":"1.1","math":"\(A\)"}. Code example 1 Let’s try this on Python. First we create a square matrix C3×3{"version":"1.1","math":"\(C_{3\times3}\)"}.   We then invert the matrix using the NumPy library. # note, we need a square matrix (# rows = # cols), use C: C = np.random.randn(3,3) C_inverse = np.linalg.inv(C) print(C_inverse) This outputs the inverted matrix. [[-0.4956578   1.77333405  0.14485167]  [-0.03878645  0.81376284 -0.27251826]  [-0.72828746 -0.10638659 -0.26419485]] Code example 2 Now let’s check that C×C−1=I{"version":"1.1","math":"\(C\times C^{-1} = I\)"}  print("-------------------------------------------------------") print(C.dot(C_inverse)) print("-------------------------------------------------------") print("Is identical to:") print(C_inverse.dot(C)) print("--------------------------------------------------------") This outputs the following. ------------------------------------------------------- [[ 1.00000000e+00 -1.47512803e-16  5.58255356e-17]  [-1.19617664e-17  1.00000000e+00  1.66630989e-17]  [ 1.28900332e-17 -1.53900921e-17  1.00000000e+00]] ------------------------------------------------------- Is identical to: [[ 1.00000000e+00  1.29458725e-16 -3.84871921e-17]  [ 1.72083657e-17  1.00000000e+00 -7.45734805e-18]  [ 1.65856322e-17  2.32491643e-16  1.00000000e+00]] -------------------------------------------------------- Transposing a matrix At times it is useful to pivot a matrix for conformability. As an example, we may need to switch the rows and column dimensions of matrices in order to divide or multiply matrices. Consider the following matrix: A3×2=[a11a12a21a22a31a32]3×2{"version":"1.1","math":"A_{3 \times 2}=\begin{bmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \\ a_{31} & a_{32} \end{bmatrix}_{3 \times 2}"} The transpose of A (denoted as A′{"version":"1.1","math":"\(A^{\prime}\)"} is:  A′=[a11a21a31a12a22a32]2×3{"version":"1.1","math":"A^{\prime}=\begin{bmatrix} a_{11} & a_{21} & a_{31} \\ a_{12} & a_{22} & a_{32} \\ \end{bmatrix}_{2 \times 3}"}  Code example 3 Let’s see how we code this in Python. We are using two specialist routines in the library to initially create a matrix. You can find more information on the routines reshape and arange if you want to know how the matrices are initialised. A = np.arange(6).reshape((3,2)) B = np.arange(8).reshape((2,4)) print("A is") print(A) print("-------------------") print("The Transpose of A is") print(A.T) The output of the code is given below: A is [[0 1]  [2 3]  [4 5]] ------------------- The Transpose of A is [[0 2 4]  [1 3 5]] One important property of transposing a matrix is the transpose of the product of two matrices. Let matrix A{"version":"1.1","math":"\(A\)"} be of dimension n×m{"version":"1.1","math":"\(n \times m\)"} and let B{"version":"1.1","math":"\(B\)"} be of dimension of m×p{"version":"1.1","math":"\(m \times p\)"}. Then (AB)′=B′A′{"version":"1.1","math":"\((AB)^{\prime}=B^{\prime}A^{\prime}\)"} You can research more information on any of the resources we’ve presented for you and, as always, ask questions on the discussion forum. Activity Make sure that you have experimented with all the individual Python coding examples in this lesson. Useful matrix manipulation code in Python There will be times where you will need to access individual rows or columns from a matrix. There may be other times where you may need to do logical checks on array elements. The following code segments will be handy in such situations. Slicing Accessing elements of NumPy matrices and arrays. Code example 1 This code grabs the first column of  A{"version":"1.1","math":"\(A\)"}: print(A) A[:,0] As you can see index 0 refers to the first column. The output is given below: [[0 1]   [2 3]   [4 5]]   array([0, 2, 4])  Alternatively or, we could grab a particular element (in this case, the second column, last row): Code example 2 You can extract a part of a list/string using the syntax [start:stop], which extracts characters between index start and stop. |T| h| i| s|  | i| s|  | a|  | s| t| r| i| n| g| .||-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-||0|  1|  2|  3|  4|  5|  6|  7|  8|  9| 10| 11| 12| 13| 14| 15| 16| s = "This is a string." # [start:stop:step] print("------------------------") print(s[2:10:1]) print("------------------------") # These two are equal print(s[0:10:2]) print("------------------------") print(s[:10:2]) print("------------------------") The output of this slicing string is as below: ------------------------ is is a  ------------------------ Ti sa ------------------------ Ti sa ------------------------ Logical checks to extract values from matrices/arrays: Consider the matrix: A=[012345]{"version":"1.1","math":"A=\begin{bmatrix} 0 & 1 \\ 2 & 3 \\ 4 & 5 \end{bmatrix}"} If we want to verify which elements in column two (2) are greater than 4, we can run the following code. Code example 3 print("Boolean-->",A[:,1]>4) ## index print("--------") print("Index number-->",np.argmax(A[:,1]>4)) ## index print("--------") print("Values-->",A[A[:,1]>4]) ## value This outputs the following. Again keep in mind that element indexes start from 0. The second column is referenced using index 1. Boolean--> [False False  True] -------- Index number--> 2 -------- Values--> [[4 5]] For loops Create a 12x12 matrix and print it out: Code example 4 A = np.arange(24).reshape((12,2)) print(A) print(A.shape) The code contains two print commands. The first prints the matrix and the second prints the shape of the matrix (it has 12 rows and 2 columns). [[ 0  1]   [ 2  3]   [ 4  5]   [ 6  7]   [ 8  9]   [10 11]   [12 13]   [14 15]   [16 17]   [18 19]   [20 21]   [22 23]]   (12, 2)  Code example 5 The following code is an example of how a for-loop can be used to access each row of a matrix. This is more efficient than using element references. for rows in A: print(rows) The output is listed below: [0 1]   [2 3]   [4 5]   [6 7]   [8 9]   [10 11]   [12 13]   [14 15]   [16 17]   [18 19]   [20 21]   [22 23] Branching and decisions Syntax, in this case indentation, and conditionals (decisions) are another two essential elements of coding. Python code blocks are defined by their indentation level. Program structure is controlled by how far lines of code are indented. Be careful how the code is laid out or you will get unexpected results or a broken program that will not run. Conditionals and decision trees Decisions are resolved by checking the condition of a variable. Is the cup empty? The answer can only be Yes or no. True or false. The answer is ‘boolean’ - the digital bit is either on or off. Using our ‘trips around the city’ example,   would need to ask, ‘Is this trip less than or equal to 25 km?’. Let’s imagine this data point (a trip) is 15 km. The answer to the question will be ‘True’. We can then ask the machine to put the trip into a cluster containing trips under 25 km. Enter this simple code into your Python setup: trip1 = 15 if trip1 <= 25:      print("This trip goes into the 25 km and under cluster") else:     print("This trip goes into the over 25 km cluster") You will get the following output: This trip goes into the 25 km and under cluster The Python syntax for conditional execution of code use the keywords if{"version":"1.1","math":"\(if\)"}, elif{"version":"1.1","math":"\(elif\)"} , (else if), else{"version":"1.1","math":"\(else\)"}.  Run the code below: Code example 1 statement1 = True statement2 = False if statement1:      print("First statement is true") elif statement2:     print("Second statement is true") else:     print("Both statements are false") print("This is printed outside the if-else block") You will get the following output: First statement is true This is printed outside the if-else block The type of statement1 and statement2 is boolean{"version":"1.1","math":"\(boolean\)"}. You can check this by running the type(statement1). Python also treats any non zero integer as true{"version":"1.1","math":"\(true\)"}. Indentation Run the following blocks for an experiment with indentation: Code example 2 # nothing happens because this code doesn't produce any output statement1 = False  if statement1:     print("printed if statement1 is True")     print("still inside the if block") You will get no output: if statement1:     print("printed if statement1 is True") print("now outside the if block") You will get the following output: now outside the if block Activity Defining Machine Learning What makes Machine Learning (ML) different from a simple computer program? The 1959 definition below makes Machine Learning (ML) seem like magic: “Field of study that gives computers the ability to learn without being explicitly programmed,”(Samuel 1959) As we explore further you will see ML is a set of tools to derive meaning from data. For now, here is another definition that describes ML in mathematical terms. Machine Learning as an equation “A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E,”(Mitchell 1997, p. 2) This is an elaborated, perhaps overly complicated definition of how a computer program learns. It learns only when performance improves with experience. So, what is experience? It is the data that we provide for the machine to process. Experience E, is the information the machine processes using the tasks T, to get closer to what you want to produce, the performance measure P. If the machine continues to perform the tasks but produces rubbish then it hasn’t learned. A machine can be said to learn if it can perform tasks on the information you supply, and react to the data to get results that get closer to a useful result over time. Consider how humans learn and make decisions. We analyse data, find patterns and use those patterns to make decisions or to predict the outcome of future events. For example, if you buy a car, you might look up reviews, check the features of different models, think about how you want to use the car, take some test drives and then make a choice. Too much data So why do we need ML? It is all about the volume of data available to us. There is so much information that we cannot make sense of it. It’s as though you have to choose the perfect vehicle for every person at Deakin. It would be a massive task to know what every person wants and needs and to add all the details of various models of vehicle in order to make good decisions. Automated systems (ML) will learn from the data we give them and, importantly, respond to changes in the data they are given to produce useful results. Activity How would you define machine learning? Do a bit more reading and come up with your own definition. Share your response in the discussion forum Readings Samuel, A 1959 ‘Some Studies in Machine Learning Using the Game of Checkers’, IBM Journal of Research and Development, vol. 3, no. 3, pp. 210–229. Distances between vectors Cosine similarity is a similarity function often useful in information retrieval. It measures the cosine of the angle between two vectors. So Cosine similarity is defined to be a measure of similarity between two vectors of an inner product space. On the other hand, cosine distance measures the angular difference between 2 vectors. In other words, the cosine distance seeks to express vector dissimilarity in positive space and hence it does this by subtracting the similarity from 1. Figure. cosine similarity and cosine distance The cosine distance above is defined for positive values only. Cosine distance can be computed via Euclidean distance if vectors are made unit vectors. Activity We have three vectors, A=[1 5 2 9], B=[5 8 2 9] and C=[3, 0, 2, 6]. Find the relation between Distance(A,B) and Distance(A,C) using various distance measures explained in this article Essential skills and concepts We’re going to leap in and make this first topic a big topic. You will become familiar with machine learning terminology, refresh your knowledge of vectors, matrices and probability and install tools to build some simple Python programs. Learning Goals By the end of topic 2 you will be able to: discover real world applications of machine learning explore the different elements and types of machine learning algorithms review the basic concepts and skills necessary to understand building blocks of machine learning algorithms. Scope and level Students with a wide range of skill levels are participating in this Unit. Everyone has very different backgrounds and skills. If you have experience in a certain area in this cross-disciplinary field then take the opportunity to extend your knowledge with the extra resources offered or with personal exploration. You will learn a lot from explaining concepts to other students in the comments. There’s no better way to test your understanding. Python 3 Whether your coding skills are rusty or you’re a coding guru, you will need to start learning Python immediately. Your assessments require Python so it’s important to jump in, look at some programs and learn what they’re doing. Python is a clear and easy language to learn. If you have issues with learning Python programming, you can access Helphub for a one to one session. In addition, you can ask questions to your educators during the workshop and cloud seminars. You can also post your queries in the discussion forums for educators to address and share your problem with peers to solve through the forum. If you’ve coded in Python before, you will have a head start. Take a moment to help any students who are inexperienced coders. You will consolidate your own learning by explaining concepts to someone else. Beginners If you are an inexperienced coder, it’s a good idea to get started on learning Python. We have collected a range of resources (go to Resources>Reading list) for you. Try one of the beginner items on the Resources page. “Head first Python” is a visual learning online text course (so install Anaconda first) while Datacamp is an interactive real time learning method. Browse through and select one that works for you. What is an algorithm? Previous students have asked about this strange word. An algorithm is a set of instructions. Computers need precise instructions to perform tasks. An computer algorithm is written like teaching a child to make a cake. If a recipe is: ‘1 cup plain flour, 1 cup SR flour, pinch of salt, 2 eggs lightly beaten, cook mod oven 30 minutes’ there are many assumptions. A computer algorithm would require something more like: select working area near clean fresh water, a domestic oven and cooking tools activate the oven at temperature setting 180 degrees C select one ‘good bowl’ 30cm diameter, condition ‘clean’, type ‘mixing’, made of material ‘steel’    if ‘good bowl’ available, go to place bowl     if no ‘good bowl’ available, pause cooking (5 minutes) and load package 'washing up'                          if 'washing up' fails to load, call 'stop cooking', wait for further instructions. place bowl securely on a level surface convenient to your height  select one mixing implement         select a spoon of type ‘cooking’ made of material ‘wood’ featuring a handle in excess of 25cm in length          else if you have no such spoon, select a tool of type ‘spatula’ with a total length of not less than 25cm      if you have a silicone spatula select it                 else if no silicone spatula,                 then if you have a spatula of material 'flexible food-grade plastic' select it else… and so on through every little step 'stop cooking' function         deactivate oven         put away tools         buy cake at shop end Coding is a different way of thinking. Luckily there are many ready made modules we can use instead of writing all our own code. We will use NumPy, SciPy and Matplotlib amongst others. Function Functions store blocks of code so you can call them by name. Going back to our algorithm example, ‘washingup’ was a function we called and so was ‘stop cooking’. An argument is a value that you can use within the function. In the ‘washing up’ function, an argument might be (dirtything) and the value of of the variable dirtything would have been ‘bowl’. In Python it would look like this. Try it in your Jupyter Notebook: # first we create a function about washing up def washingup(dirtything):       print("We need to wash the", dirtything) # then we define the dirty thing in the variable dirtything dirtything = 'bowl' # then we call the function with the argument dirtything cookingstep = washingup(dirtything) Syntax A function in Python is defined using the keyword def{"version":"1.1","math":"\(def\)"}, followed by the function name and function arguments within parentheses (), and ends with a colon :{"version":"1.1","math":"\(:\)"} The functional Python code follow, with one additional level of indentation. This is the function body. It is recommended to use “docstring” for your functions. Docstring explains what the function does. Lets look at an example: Code example 1 def func1(s):     """     THIS BIT IS CALLED DOCSTRING similar to comments to document the code     This function prints a string 's' and returns (tells us) the number of characters in it.     """      print("Number of characters in the string: ", len(s))     return 2*len(s)  a = func1("test function") print(a) You will get the following output: Number of characters in the string:  13   26 Use the return{"version":"1.1","math":"\(return\)"} keyword for functions that return a value. A function can also return multiple values using tuples. Code example 2 def powers(x):     """     Return a few powers of x.     """     xs = x**2     xc = x**3     xf = x**4     return xs, xc, xf print(powers(3)) y1,y2,y3 = powers(2) print(y2) You will get the following output:   (9, 27, 81)   8 Anonymous Functions Anonymous functions are defined by the keyword lambda{"version":"1.1","math":"\(lambda\)"} in Python. Functions f{"version":"1.1","math":"\(f\)"} and g{"version":"1.1","math":"\(g\)"} in the cell below basically do the same thing. But g{"version":"1.1","math":"\(g\)"} is an anonymous function. Code example 3 # define a function def f(x):                      return x**2.          # x to the power of 2 - the function give us x squared # use an anonymous function instead g = lambda x: x**2.  # x to the power of 2 - in other words x squared print(f(8))   # call the f function and ask for the square of 8 print(g(8))  # call the g anonymous function and ask for the square of 8 You will get the following output. As you can see both functions return the same value.   64.0   64.0 The following Python code is another interesting example of how powerful functions can be. Increment means increase or add. In the cell below, we used anonymous function n_increment(). We create new functions by passing n{"version":"1.1","math":"\(n\)"} to n_incremenet(). For example f5{"version":"1.1","math":"\(f5\)"} and f9{"version":"1.1","math":"\(f9\)"} are functions that add 5 and 9 to their inputs respectively. Code example 4 # define a function that gives us back an anonymous function def n_increment(n):      return lambda x: x+n add5 = n_increment(5) add9 = n_increment(9) print(add5(2), add9(2)) You will get the following output:   7 11 Activity Explore all the examples demonstrated in this lesson. Change some of the code and see how they work. Did they confirm your understanding or were you confused? Iterations Loops or iterations can be programmed using for{"version":"1.1","math":"\(for\)"} and while{"version":"1.1","math":"\(while\)"}.  The for-loop is used to iterate through Python objects like lists, arrays and tuples. For loops The for loop runs for a fixed number of times, otherwise known as iterations: Enter this code into a Jupyter Notebook cell: Code example 1 exampleList = [1, 2, 3, 4, 5] for item in exampleList:       print(item) You will get the following output: 1 2 3 4 5 The following is an example using for loops to initialize lists: Code example 2 # range(start, stop) creates a range of values from start to stop-1 x = list(range(2, 6)) print("Initial list: {}".format(x)) for idx, item in enumerate(x):     x[idx] = item**2 print("The new list: {}".format(x)) You will get the following output: Initial list: [2, 3, 4, 5] The new list: [4, 9, 16, 25] During each step of the for loop, enumerate(x){"version":"1.1","math":"\(enumerate(x)\)"} iterates through the list and store the index in idx{"version":"1.1","math":"\(idx\)"} and value in item{"version":"1.1","math":"\(item\)"}. Here is a shorter way of doing it: Code example 3 newlist = [x**2 for x in range(2, 6)] print(newlist) You will get the following output: [4, 9, 16, 25] While Loops The following is an example on how to use a while loop: Code example 4. i = 0 while i < 5:       print (i, end=" ")   # prints each iteration on the same line       i += 1            # adds 1 to the variable i print()                 # prints a blank line print("done")       # Note that this is printed outside the loop You will get the following output: 0 1 2 3 4 Let's get started You will need to be able to use the Python programming language to complete your assessments. Beginners If you’ve never programmed before, Python is a good way to begin. Python is powerful and fairly simple, however if you are new to programming it will take a little while to get familiar with the ideas and jargon. It’s outside the scope of this course to teach you basic programming concepts but I’ll direct you to some very helpful resources. It would help you to spend some time this topic doing a beginner course using a recommended text. Programmers are not expected to remember everything about a language. Many coders use cheat sheets to remember how to write a piece of code or look up examples to follow. You do have to understand the code to change it and use it but remember there is no exam in this subject. You do not have to be able to code without support and resources beside you. The Discussion Forum is a good place to ask any questions you have. Bookmark it now! The next step will describe how to download and install the Anaconda distribution of Python and then we will take you through coding. Experienced Coders The next step links to the Python 3.7 Anaconda distribution installs. Python is a powerful high-level, object-oriented programming language created by Guido van Rossum. It has an easy-to-use syntax, resulting in a perfect language for someone trying to learn programming. Python is an experiment in how much freedom programmers need. Too much freedom and nobody can read another’s code; too little and expressiveness is endangered. (Rossum, 13 Aug 1996) This programming language is named after Monty Python. Many consider it a scripting language but is has many more features and functionalities to be classified this way. It has featured scalable, object oriented and functional features from the beginning. Python has been open sourced from its inception and was used by Google from the beginning. It is becoming increasingly popular with other platforms and vendors including Youtube and Dropbox. Basic features of Python interpreted: processed at runtime interactive: use Python prompt object oriented: encapsulate code in objects. Suitable language for beginners easy to learn: few keywords, simple structure, clear syntax easy to read and maintain broad standard library: portable across UNIX, Windows and Mac support for major databases support for GUI Programming If you are experienced you might want to skim the following introductory programming steps. To get ahead, go to the Topic 2 Python exercises, read some of The elements of statistical learning or reinforce your own learning by helping less experience students. Activity Machine Learning steps  Have you ever thought about how you learn to make decisions? Let’s assume that we have been asked to research a problem and make a decision. You must have access to information (data) from which you can learn. Once you have data, what do you do with it? Most people analyse the information to find patterns and relationships. You make a decision based on your work. Finally, you evaluate the model. Did you make a good decision or could it have been better? Let’s look at each of these stages in more detail and relate them to ML. Step 1: Data Manipulation This is a process of data preparation. ML usually uses the largest sets of data available. The first step in data manipulation is Data Acquisition. Data acquisition is the process of sampling information that illustrates real world physical conditions with a predefined measurement. Using our car example, you might measure engine size, number of doors, size of tyres etc. The data acquired should be reliable for converting into digital numeric values that can be manipulated by a computer. Number of car doors is easy; style is less easy to define numerically. Once the data is properly stored, any redundant, noisy, unusable parts of it should be trimmed. We call this procedure Data Cleaning. Data cleaning is a major step as real-world datasets are highly affected by noise, redundancy and missing values. We might delete any three-wheeled cars because they’re so unusual. Step 2: Analytics The second main step in machine learning is Analytics. Analytics mainly involves finding relationships and correlations in the prepared data in order to design an accurate model based on that input data. In addition, Exploratory Data Analysis is an approach for analysing datasets in order to summarise their main characteristics or features. Many exploratory data analysis methods use visual illustration of data, based on different features. Things like graphs, charts and tables make data easier to understand. Finally Predictive Machine Learning is the last stage of Analytics. It uses a variety of statistical techniques such as predictive modelling in order to build a classifier or intelligent system for decision making. We will come back to these ideas over the next few topics. Step 3: Evaluation and Visualisation The final result of Analytics is an intelligent system or model. As the last step of ML design, we have to evaluate the performance of the system. “Did I choose the right car?” If the quality and performance of the intelligent system does not achieve a satisfactory outcome, the Refinement procedure is required and another round of data manipulation and analytics becomes necessary. Again, we will come back to these ideas as you move through the Unit. In this Unit we mainly focus on the Analytics step. However it will be necessary to use parts of the Data Manipulation step to build a model. Activity If you would like another explanation of the scope and complexity possible and the methods used to make the machine learn, watch this 10 minute video from Android Authority. It goes over some of the concepts we’ve covered so far, and introduces others. Tip: if you watch it at twice the speed, it takes half as long! ML is based on maths. Maths underlies every decision, iteration and output. To get great results, you need to understand the various mathematical concepts and processes that are the foundation of your results. An expert Data Engineer will understand and apply these concepts. They will have knowledge and understanding of a range of models, the ability to select models, the parameters (or edges) to apply and understand why some models give better results than others. Some of the key areas you will explore this topic are listed below: Vectors and basic vector operations Matrices and matrix operations Basic concept of probability Matrix algebra Matrices are also a fundamental element of linear algebra and extremely useful in machine learning. Most of the machine learning methods deal with matrix operations. The main two features of any matrix is the number of rows and the number of columns. Figure. Rows and columns in matrices. Figure. Definition of a sample matrix based on number of rows and columns. Basic operations Next we review some basic operations in matrices. Matrix Addition/Subtraction You can add or subtract matrices if they are the same size. The elements in the corresponding positions are added or subtracted. [243185]+[674413]=[8117598]{"version":"1.1","math":"\begin{bmatrix} 2 & 4\\ 3 & 1 \\ 8 & 5 \end{bmatrix}+\begin{bmatrix} 6 & 7\\ 4 & 4 \\ 1& 3 \end{bmatrix}=\begin{bmatrix} 8 & 11\\ 7 & 5 \\ 9 & 8 \end{bmatrix}"} Subtraction is similarly done: [243185]−[674413]=[−4−3−1−372]{"version":"1.1","math":"\begin{bmatrix} 2 & 4\\ 3 & 1 \\ 8 & 5 \end{bmatrix}-\begin{bmatrix} 6 & 7\\ 4 & 4 \\ 1& 3 \end{bmatrix}=\begin{bmatrix} -4 & -3\\ -1 & -3 \\ 7 & 2 \end{bmatrix}"} Scalar Multiplication/Division To multiply a matrix A{"version":"1.1","math":"\(A\)"} with scalar a{"version":"1.1","math":"\(a\)"}, multiply each element of  A{"version":"1.1","math":"\(A\)"} and a{"version":"1.1","math":"\(a\)"} as below:  3×[674413]=[1821121239]{"version":"1.1","math":"3\times\begin{bmatrix} 6 & 7\\ 4 & 4 \\ 1& 3 \end{bmatrix}=\begin{bmatrix} 18 & 21\\ 12 & 12 \\ 3 & 9 \end{bmatrix}"} Division is similarly done except that division by 0 is not allowed for obvious reasons. Elementwise Matrix Multiplication You can multiply any two matrices element-wise if they have the same size. Consider A⨀B=C{"version":"1.1","math":"\(A\bigodot B = C\)"}. Now C(i,j){"version":"1.1","math":"\(C(i,j)\)"} is computed as product of A(i,j){"version":"1.1","math":"\(A(i,j)\)"} and B(i,j){"version":"1.1","math":"\(B(i,j)\)"}. [243185]⨀[674413]=[1228124815]{"version":"1.1","math":"\begin{bmatrix} 2 & 4\\ 3 & 1 \\ 8 & 5 \end{bmatrix}\bigodot\begin{bmatrix} 6 & 7\\ 4 & 4 \\ 1& 3 \end{bmatrix}=\begin{bmatrix} 12 & 28\\ 12 & 4 \\ 8 & 15 \end{bmatrix}"} Matrix to Matrix Multiplication You can multiply any two matrices if the number of columns in the first matrix is equal to the number of rows in the second matrix. Consider AB=C{"version":"1.1","math":"\(AB = C\)"}.  Now C(i,j){"version":"1.1","math":"\(C(i,j)\)"} is computed by dot product of A(i,:){"version":"1.1","math":"\(A(i,:)\)"} and B(:,j){"version":"1.1","math":"\(B(:,j)\)"}. [245617][1213]=[6161128823]{"version":"1.1","math":"\begin{bmatrix} 2 & 4\\ 5 & 6 \\ 1 & 7 \end{bmatrix}\begin{bmatrix} 1 & 2\\ 1 & 3 \end{bmatrix}=\begin{bmatrix} 6 & 16\\ 11 & 28 \\ 8 & 23 \end{bmatrix}"} Note: Matrix multiplication is NOT commutative. In other words, multiplication order matters. In general AB≠BA{"version":"1.1","math":"\(AB \neq BA\)"}.  In some case they may not even be size compatible if multiplied in the other order. Rectangular and Square Matrices If a matrix A{"version":"1.1","math":"\(A\)"} has size m×n{"version":"1.1","math":"\(m \times n\)"} such that m=n{"version":"1.1","math":"\(m = n\)"}, then it is called a square matrix; otherwise it is a rectangular matrix. [1623]{"version":"1.1","math":"\begin{bmatrix}1 & 6\\2 & 3\end{bmatrix}"} is a square matrix and [125624]{"version":"1.1","math":"\begin{bmatrix}1 &2& 5\\ 6&2 & 4\end{bmatrix}"} is a rectangular matrix. Transpose of a Matrix The transpose of a matrix A{"version":"1.1","math":"\(A\)"} is obtained by putting all the matrix elements on rows on its columns. Lets say B{"version":"1.1","math":"\(B\)"} is transpose of A{"version":"1.1","math":"\(A\)"} then, B(i,j)=A(j,i){"version":"1.1","math":"\(B(i,j) = A(j,i)\)"}. As an example, [167238]{"version":"1.1","math":"\begin{bmatrix}1 & 6 & 7\\2 & 3 & 8\end{bmatrix}"} is the transpose of [126378]{"version":"1.1","math":"\begin{bmatrix}1 & 2\\6 & 3 \\ 7 & 8\end{bmatrix}"}. Symmetric Matrices A matrix A is called symmetric if it is equal to its transpose, that is A=AT{"version":"1.1","math":"\(A = A^T\)"}. Symmetric matrices are always square matrices.  A=[1447]{"version":"1.1","math":"A = \begin{bmatrix}1 &amp; 4\\4 &amp; 7\end{bmatrix}"} is a symmetric matrix of size 2×2{"version":"1.1","math":"\(2\times2\)"}.  Diagonal Matrix A matrix A{"version":"1.1","math":"\(A\)"} is called a diagonal matrix if A(i,j)=0{"version":"1.1","math":"\(A(i,j) = 0\)"} for all i≠j{"version":"1.1","math":"\(i \neq j\)"}. Diagonal matrix is always a square matrix. The following is an example: A=[200060005]{"version":"1.1","math":"A = \begin{bmatrix} 2 & 0 & 0\\ 0 & 6 & 0 \\ 0 & 0 & 5 \end{bmatrix}"} is a diagonal matrix. Identity Matrix A matrix I{"version":"1.1","math":"\(I\)"} is called an identity matrix if it is a diagonal matrix and I(i,i)=1{"version":"1.1","math":"\(I(i,i) = 1\)"}. The following is an example: I=[100010001]{"version":"1.1","math":"I = \begin{bmatrix} 1 & 0 & 0\\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}"} Note that we often use In×n{"version":"1.1","math":"\(I_{n \times n}\)"} to denote an identity matrix of size n×n{"version":"1.1","math":"\(n\times n\)"}.  Inverse of a Matrix A matrix A is called as inverse of matrix B, if and only if BA=AB=I{"version":"1.1","math":"\(BA = AB = I\)"}. Since AB=BA{"version":"1.1","math":"\(AB = BA\)"} both A{"version":"1.1","math":"\(A\)"} and B{"version":"1.1","math":"\(B\)"} need to be a square matrix. If A is inverse of B, we denote it as A=B−1{"version":"1.1","math":"\(A = B^{-1}\)"}.  Note: Inverse of a matrix A{"version":"1.1","math":"\(A\)"} exists only if its determinant is nonzero. Orthogonal Matrix A square matrix U{"version":"1.1","math":"\(U\)"} is called an orthogonal matrix if its transpose is equal to its inverse, UT=U−1{"version":"1.1","math":"\(U^T = U^{-1}\)"}. Based on the definition, any identity matrix is orthogonal. The other examples of orthogonal matrices are rotation matrices. The following is an example of an orthogonal matrix: I=[cos(x)sin(x)−sin(x)cos(x)]{"version":"1.1","math":"I = \begin{bmatrix} cos(x) & sin(x)\\ -sin(x) & cos(x) \\ \end{bmatrix}"} Other Concepts related to a Matrix There are many concepts regarding matrices such as: Determinant of a matrix Trace of a matrix Linear Independence Rank of a matrix Eigen values/Eigen vectors of a matrix We will cover some of these concepts later in the Unit. Activity Need a refresher for matrices? Do your own research or try this free Khan academy introduction to catch up. Extension: Read and watch the following material and discuss your learning about Eigenvalues and Eigenvectors: Eigenvalues and Eigenvectors Introduction to Eigenvalues Finding Eigenvalues and Eigenvectors 3Blue1Brown Eigenvalues Watch the 3Blue1Brown video. For in-depth knowledge, you may want to watch Chapters 3, 4, 5, 6 as well. Challenge: Model evaluation In machine learning problems, we should always evaluate a model to determine if it will do an excellent job of predicting the labels on new and future test data. Because future instances have unknown label values, we need to check the accuracy of a machine learning model on test data with correct labels that we already know. We use this assessment as a proxy for predictive accuracy on future data (which is unknown to us!). For this purpose we need to: randomly split examples into a training dataset and test dataset use the training dataset to learn a model. evaluate the model using the test dataset and a measurement (such as the accuracy of prediction) repeat for different random splits and then average the results. check the accuracy of results and try again (iterate) until the model makes useful predictions Figure. As the number of training examples grows, we can design a more accurate classifier. Model selection One of the most challenging tasks in the assessment of machine learning models is to find the BEST model or best fit hypothesis. As we discussed earlier in our ‘trips around the city’ example, there are many ways of grouping and combining data and many ways to adjust the model’s controls (parameters and hyper-parameters). This will vary a model’s fitness to the data. There is no easy way to know if a certain model will offer the best fit. There is so much data and so many possible features that we can’t be sure which model to choose. That’s why we have to try many different models. Trying out models If you remember the clustering problem we discussed previously, we are not sure about the exact number of clusters, so we cannot know the best or most accurate or most useful model. The models we choose will have a direct effect on the quality of the output. Figure. The clustering problem and the challenges in model selection. There are many effective ways that people approach this problem: look at averaged evaluation scores on many random test datasets cross-validation, that is train using one dataset and test on another, try rotating them and test again, for example if you have datasets A, B and C try AIC, BIC etc. This additional Model Evaluation video gives another explanation of the process of finding a best fit model. Over-fitting ⚠ Caution ⚠ Sometimes when a model learns the details and noise within a training dataset the knowledge can negatively impact the performance of the model on a new dataset. In machine learning, we call this *Over-fitting*. In other words, designing a model to suit the training dataset can result in poor performance on evaluation or new data. Activity Perform your own exploration of model evaluation and try to understand the differences between training, validation and test datasets. This additional video might be helpful. For another explanation of overfitting you might like to watch this excellent additional video. Real-world applications of machine learning Machine learning involves the use of computer algorithms to learn how to perform different tasks. Let’s look at a few examples where machine learning is being applied. Robotics Robots are going to be our companions in the future. They will do our cleaning, cooking and vacuuming. They’ll do our reading, schedule tasks, remind us to take our medications and play our favourite song at just the right time and volume. Machine learning is a fundamental part of enabling robots to perform these activities. Some examples of machine learning applications in robotics are creating walking and jumping patterns for humanoid robots and tuning the way a prosthetic leg moves in relation to the other leg of a one-legged patient. Simultaneous Localization and Mapping (SLAM) uses data to find routes for rescue robots. Check out this amazing demonstration of real-time mapping using the pulsing light of LIDAR. Computer vision Board Games Board games are one of the oldest applications of machine learning. There are many successful algorithms which play checkers and board games such as ‘Go’. In March 2016; AlphaGo, the board-game-playing AI from Google’s DeepMind beat Korean Go Champion Lee Sedol 4-1. AlphaGo uses deep neural networks and Monte Carlo tree search. Watch this 3 minute trailer for the AlphaGo documentary. The win is a defining moment in AI similar to when the computer, Deep Blue, beat Garry Kasparov at chess in 1996. This is an additional video, hosted on YouTube. Voice Recognition Speech recognition and machine learning have experienced waves of major innovations through recent history. It has benefited from advances in deep learning, as well as big data and is widely used in a variety of applications. Technologies such as Siri and Google Home are examples of this. Siri uses speech recognizer, natural language processing and text-to-speech techniques. The Australian Government Tax Office now holds millions of voice prints to identify Australians. Their voice is compared with a stored voiceprint which captures more than 140 unique physical and behavioural characteristics of a person such as length of the vocal tract and nasal passage, the size and shape of the larynx, pitch, cadence and accent. (Nott, 2016) How would you go at recognising people by voice? How about a million people? This is where machine learning excels. Digit Recognition Digit Recognition is the task of reading in the images of handwritten numbers and letters and outputting its machine-encoded equivalent. Machine Learning methods (SVM and Deep Learning) have hit >99% accuracy for this task. Other examples are detection of numberplates, printed numbers on bills, handwriting and CAPTCHA. Other interesting applications A wide variety of machine learning applications are related to: healthcare analytics: diagnosis and prognosis stock market prediction business analytics facial recognition Activity The Learner, Environment, Observations and Actions are the 4 major players in reinforcement learning Reinforcement learning Reinforcement learning is another important type of machine learning algorithm. In this algorithm, an agent learns how to behave in an environment by performing actions and learning from interactions. Learning from “interaction with the environment” replicates the way humans learn by instinct, curiosity and experimentation. The learner (a machine or a human) acts on its environment, receives some evaluation based on its action (reward), but is not told which action is the correct one for a desired end goal. The learner’s actions affect the data it receives later. There are many logic games like Chess, with a sequence of decisions. It is possible to train an agent to learn how to play Chess by reinforcement learning; if the actions and the corresponding rewards are well defined. For example, if I move my Queen out to a vulnerable square, it gets taken off the board. I lose. Next time I’ll try something different. Activity Other than applications in games, can you find an example where reinforcement learning is used in machine learning? Justify you answer. Share your response in the discussion forum. You might like to watch a video or two if you are still developing an understanding of these concepts. We’ll be coming back to them but getting a good grounding now might save you time later. This is an additional video, hosted on YouTube. This is an additional video, hosted on YouTube. Some special matrices The representation of a set of documents as vectors is known as the vector space model. It is a fundamental step in information retrieval operations. These operations can vary from a simple query problem to real search engines. In the text data representation step we had two documents with their corresponding feature vectors. By calculating the euclidean distance, we can easily find the distance between these two documents. It can be utilised as a quick way to find the closeness of two documents. Figure. Calculating the distance of two text vectors representing two documents. Activity Create your own example of documents and vocabulary to compare their similarity based on the example shown above. Supervised learning overview The majority of practical ML uses supervised learning. This brief overview will give you a broad understanding of supervised learning. It’s an important concept and we’ll be going into much more detail in the up coming topics. What is supervised learning? Supervised learning can be defined as:learning a function (otherwise known as a model) from data to relate inputs to known outputs. If the concept is unfamiliar it may take several different descriptions or definitions to make sense of the idea. Supervised learning is trained One defining characteristic of supervised learning is that datasets have relationships built in from the start. For example, if you have datasets on vehicles you know that most cars have four wheels while most bicycles have two. You could say that having two wheels is a function of being a bicycle (with some exceptions) and having four wheels is a function of being a car (with the exception of very rare three-wheeled cars like this Fuldamobil S-7). This makes it possible to train the algorithm. The machine learns using known relationships in the data. Training and evaluation data For supervised learning, training requires dividing the available data into training data and evaluation data. Most of the data is used to develop and train a function ‘model’. We know the relationship between the inputs and the outputs. In other words, we know the ‘right’ answers so we can select, manipulate and refine features to train the machine. The more often the answer is correct, (ie. “This is a bicycle”), the closer you are to having a useful algorithm. The evaluation data can be used to test the model with fresh, unused input data. A mathematical definition Machine algorithms must be described mathematically. Remember that computers understand numbers so we must translate our questions into formulas or algorithms so they can process answers. In supervised learning, the training data includes output information (labels/targets). Target function: f:X→Y{"version":"1.1","math":"\(f: X \rightarrow Y\)"} Examples: It is in the form of (x,y){"version":"1.1","math":"\((x,y)\)"}, denoted as (x1,y1){"version":"1.1","math":"\((x_1,y_1)\)"}, ...{"version":"1.1","math":"\(...\)"}, (xn,yn){"version":"1.1","math":"\((x_n , y_n)\)"}. Hypothesis g:X→Y{"version":"1.1","math":"\(g: X \rightarrow Y\)"} such that  g(x)=f(x){"version":"1.1","math":"\(g(x) = f(x)\)"}. x = set of attribute values (attribute-value representation). y = a discrete label (classification), a real valued number (regression). Two types of supervised learning Classification problems In a supervised learning problem with two classes, decision boundaries are a hyper-surface that partitions data space into two sets, each of these sets represent one of the classes. In other words, you divide the data according to a trained algorithm. Consider the following figure as an illustration of supervised learning. Figure. Supervised learning, with linear decision boundary vs non-linear decision boundary. As you can see on the left, in some less complex cases a linear decision boundary can solve the classification problem. However as illustrated on the right, more complex cases, require complicated decision boundaries. This video describes ML and the classification problem in more detail. Make sure you have a good overview of this concept before you keep going (we will also be coming back to this topic later). This is an additional video, hosted on YouTube 2. Regression problems Another example of supervised learning, is regression. The overall idea of regression is to examine the relationship between response variables and one or more predictor variables. This examination can result in a hyperplane, representing the regression analysis. The following figure, illustrates a regression problem in 2 dimensions. Figure. Regression problem in 2 dimensions (X1{"version":"1.1","math":"\(X_1\)"} and X2{"version":"1.1","math":"\(X_2\)"}). Activity Types of variables You installed Python Anaconda in the previous step. It’s time to start some coding. Once again, if you are experienced you might want to skim the introductory programming steps. To get ahead, go to the Topic 2 Python exercises, read some of The elements of statistical learning or reinforce your own learning by helping less experienced students in the Comments here or on the discussion forum. If you haven’t installed Python and an Integrated Development Environment (IDE) yet, you can use this online IDE for experimenting with these basic coding examples but you will need to install Anaconda soon. Instructions are in the previous step. Let’s start by exploring some basic features of Python programming. Don’t worry if you are completely new to this. The traditional ‘Hello world’ Run the following cell in your Python IDE (i.e. Jupyter Notebook, which is contained within Anaconda). Code example 1 print("Hello, World!") print('Hello, World!') Successful execution of the code will generate the following output: Hello, World! Hello, World! Is there any difference in the output? So it’s possible to say the same thing in different ways. Now it’s your turn to code. Write a Python code that will print your name. Inserting Comments You should insert comments to improve the readability of your program and to remind you what each line of code does. You might think you’ll remember but you won’t. There are three ways to insert comments. Run the following cell. Will it give you any output? Code example 2 # This is a one-line comment ''' This is a  multi-line comment ''' """ This is also a multi-line comment """ print("I don't see any comments") Successful execution of the code will generate the following output: I don't see any comments Variables Variable are containers. They’re like a bowls or cups. You can put a variety of things in them, but the bowl doesn’t change. Variable names in Python can contain letters and numbers. You don’t need to explicitly define the type of variable. But you can inspect the variable type using the type(){"version":"1.1","math":"\(type()\)"}  command. Run the code below. Code example 3 x = 10 type(x) You will get the following output: int Assign a floating point number (eg. 1.3) and then a string (eg. “hello”) for x{"version":"1.1","math":"\(x\)"}  and run the above code. Observe the output. Lists List is the most versatile and common data type in Python. Lists can contain values of different types. The syntax for creating lists in Python is list_name = [item_0, item_1, …, item_n]. Try the following code: Code example 4 mylist = [1, 5, 2.57, 'abc', 4.09] print(type(mylist))   # prints the type print(mylist)   # prints the entire list print("Length of the list is: ", len(mylist)) You will get the following output: <class 'list'> [1, 5, 2.57, 'abc', 4.09] Length of the list is:  5 List indexing starts from 0{"version":"1.1","math":"\(0\)"} and ends with −1{"version":"1.1","math":"\(-1\)"}. The index of −1{"version":"1.1","math":"\(-1\)"}  represents the last element. Experiment with the following code: Code example 5 # indexing numbers = [1, 2, 3, 4, 5, 6, 7, 8] print(numbers[0]) print(numbers[3]) print(numbers[-1])    # last element print(numbers[-2])    # can you guess the result? Your output will look similar to what’s below: 1 4 8 7 Tuple data type A tuple is like a list, but the items cannot be changed once initiated. Indexing rules are similar to lists. Syntax: tuple_name = (item_1, item_2, …., item_n) Try the following code: Code example 6 states = ('VIC', 'NSW', 'QLD', 'WA', 'ACT', 'NT', 'TAS', 'SA') print(type(states)) print(states) You will get the following output: <class 'tuple'> ('VIC', 'NSW', 'QLD', 'WA', 'ACT', 'NT', 'TAS', 'SA') If you executed all this code (Code examples 1 to 6) within a single instance (or cell) of the IDE Jupyter notebook, all previously declared variables are still accessible to new code. So, let’s try to use the previously declared list numbers{"version":"1.1","math":"\(numbers\)"} with the new tuple states{"version":"1.1","math":"\(states\)"} we declared just now. If the previous sentence made no sense to you, then consider taking some beginners lessons in Python and programming concepts. We have collected a range of resources for you. Try one of the beginner items in the Resources list. “Head first Python” is a visual learning online text course (so install Anaconda first) while Datacamp is an interactive real-time learning method. Try the following code. In this we will change both the value of the list numbers{"version":"1.1","math":"\(numbers\)"} and the tuple states{"version":"1.1","math":"\(states\)"}.  Code example 7 numbers[2] = 32.56 #states[2] = 'Idontknow' print(numbers) print(states) You will get the following output: [1, 2, 32.56, 4, 5, 6, 7, 8] ('VIC', 'NSW', 'QLD', 'WA', 'ACT', 'NT', 'TAS', 'SA') Try uncommenting the second line and running it. What’s the output? Dictionaries Dictionaries are similar to lists, except that each element is a key-value pair. The syntax for dictionaries is {key1 : value1, …}. Note that the values{"version":"1.1","math":"\(values\)"} can be of any type, even another dictionary. You can access and manipulate the values of a dictionary using its keys{"version":"1.1","math":"\(keys\)"}. Try the following code: Code example 8 dict = {}  dict['one'] = "This is one"  dict[2] = "This is two"  print(dict['one']) print(dict) dict['one'] = "One has changed" print(dict['one']) You will get the following output: This is one {'one': 'This is one', 2: 'This is two'} One has changed Strings Strings are used to store text and have the same indexing rules as lists and tuples. Let’s try an example. Run the code below: Code example 9 str = "Monty Python and the flying circus!" print(str)          # Prints complete string  print(str[0])       # Prints first character of the string  print(str[2:5])     # Prints characters starting from 3rd to 5th  print(str[2:])      # Prints string starting from 3rd character  print(str * 2)      # Prints string two times print(str + "TEST") # Prints concatenated string  The numbers relate to the index of the letters. The index is the numerical position of characters in the string starting at 0. In this example, index 0 = M. You will get the following output: Monty Python and the flying circus! M nty nty Python and the flying circus! Monty Python and the flying circus!Monty Python and the flying circus! Monty Python and the flying circus!TEST Slicing with Lists and Strings You can extract a part of a list/string using the syntax [start:stop], which extracts characters between index start and stop. Code example 10 # slicing l = [1, 2, 3, 4, 5, 6, 7, 8] s = "This is a string." print(l[2:5]) print(s[0:6]) You will get the following output: [3, 4, 5] This i You can define a step for slicing as in [start:stop:step]. Lets examine what it does: Code example 11 # [start:stop:step] print(s[2:10:1]) print # These two are equal print(s[0:10:2]) print(s[:10:2]) You will get the following output: is is a  Ti sa Ti sa Slicing can be a negative value as well. Try the following example: Code example 11 print(s[10:2:-1]) print # reversing a list or string print(s[::-1]) You will get the following output: s a si s .gnirts a si sihT Define a string with value equal to “Python is fun!”. How can you print every third character of this string? Activity Template for all occasions Unsupervised learning overview This brief introduction will give you an overview of the material we will cover in topics 3 and 4. The main question in unsupervised learning is How do you find the underlying structure of a dataset which is unlabelled? How does an algorithm learn patterns from (unlabelled) data (x1,...,xn){"version":"1.1","math":"\((x_1, ...,x_n)\)"}. In other words, can a machine algorithm learn from very large sets of data without additional information about the data? Can it find patterns and relationships, make sense of data and make decisions or predictions? For example, if you had lots of data on all the ways people move around a city: long trips, short trips, time of day, vehicle type, direction of travel etc in a mixed up dataset without labels, would machine learning be able to make sense of it and tell you when to leave home to get to work on time? Popular approaches in unsupervised learning are: clustering (similarity-based), density estimation factor analysis Clustering Clustering is the process of grouping similar points together. The goal of this unsupervised machine learning technique is to find relative similarities in the data points. But why do we need to perform this task? Because it will give us insight into underlying patterns or different groups within the dataset(s). Let’s consider an example. The unlabelled data points (before clustering) are shown at the top of the following figure. Figure. Performing clustering on unlabelled data, resulting in extracting 2 clusters, 3 clusters and 4 clusters. By performing clustering based on the similarities and correlations, we might find 2 clusters in these data points. For example, we might determine trips around the city of less than 25 km and more than 25 km. This creates two groups. The art is in working out if 25 km is a good cut-off point. Is it useful? Perhaps it would be more useful to extract more clusters. We can perform the clustering in a way that results in more than two clusters. Let’s say 3 or even 4 clusters. We might have a cluster of trips that are more than 1 km and less than 10 km. Then perhaps the machine might overlay that with a cluster of pedestrian data. Would that be useful? How could you make it better? Since the data is unlabelled in clustering problems, based on the features and the expectation of the user from the behaviour of the data, we can look for any number of clusters. Say my expectation is that most trips in the city are less than 10 km. If the algorithm presents me with a cluster that contains trips of less than 15 metres, is that useful? It depends on what I’m trying to find out. Perhaps I would change that parameter. A real-world example The popular entertainment company Netflix opened a competition for the best collaborative filtering algorithm to predict user ratings for films. They provided a training data set of 100,480,507{"version":"1.1","math":"\(100,480,507\)"} movie ratings that 480,189{"version":"1.1","math":"\(480,189\)"} users gave to 17,770{"version":"1.1","math":"\(17,770\)"} movies.  This competition was a real “Movie Recommendation Problem”. They were expecting contestants to predict movie ratings for users. The winning Bellkor solution won the small team 1 million dollars from Netflix. In such problems there are no labels available for data points. That is why we are categorizing such problems as unsupervised learning. Figure. Sample rankings for random movies. The question marks are representing the rankings which are required to be predicted by unsupervised learning algorithms. Generally, the potential tasks for ML unsupervised learning are: information retrieval data compression (reduction) anomaly detection data understanding and visualization We will cover some of these tasks later in this Unit. Activity Do some research and provide a real-life example from machine learning that uses unsupervised learning. Justify why it classifies as unsupervised learning and not supervised learning. Vectors It’s outside the scope of this Unit to teach you maths skills but we will quickly do some revision of some mathematical concepts. Vectors are a fundamental element of linear algebra and mathematics. They are also widely-used in machine learning algorithms. Why know the maths? Understanding the mathematics allows you to select the best models for a task. It will support your decisions and provide the expertise to perform useful adjustments. Knowing how the maths operates within the models gives specialists the skill to manipulate data and extract the best information. You can develop machine learning without in-depth knowledge of vectors, matrices and probability but it will be harder to get the best outcomes. Even though the various pre-programmed modules conceal some of the maths (we’ll start using modules later this topic) if you understand how they work, you will have more control of your results. Remember, there is no exam in this Unit. You are not expected to perform mathematical tasks under pressure. Feature vectors Why are we using vectors? In this unit, you will notice that most of the time a data instance is represented by a vector, more precisely, by a feature vector. Text documents, images, audio files, etc. are examples of data objects. Computation on these data objects can be performed using their vector representation. What is a vector? Visually, a vector quantity has both magnitude and direction but it is really a series of related numbers. Their role in ML is about relationships between data objects. The following is an illustration of a sample vector. Note the relationship between the visual representation and the matrix representation of the relationship between inputs and outputs. Figure. Description of vector. Vector operations There are three main operations in vectors. As we’ve seen vectors can be represented as a one column matrix. Transpose Add Inner product Let’s start by taking two simple matrices x{"version":"1.1","math":"\(x\)"} and y{"version":"1.1","math":"\(y\)"}: x=[x1x2⋮xn]{"version":"1.1","math":"\textbf{x} = \begin{bmatrix} x_{1} \\ x_{2} \\ \vdots \\ x_{n} \end{bmatrix}"} y=[y1y2⋮yn]{"version":"1.1","math":"\textbf{y} = \begin{bmatrix} y_{1} \\ y_{2} \\ \vdots \\ y_{n} \end{bmatrix}"} How are these three operations implemented? Transpose xT=[x1,x2,…,xn]{"version":"1.1","math":"\textbf{x}^T = \begin{bmatrix} x_{1}, x_{2}, \ldots, x_{n} \end{bmatrix}"} Add x+y=[x1x2⋮xn]+[y1y2⋮yn]=[x1+y1x2+y2⋮xn+yn]{"version":"1.1","math":"\textbf{x} + \textbf{y} = \begin{bmatrix} x_{1} \\ x_{2} \\ \vdots \\ x_{n} \end{bmatrix}+\begin{bmatrix} y_{1} \\ y_{2} \\ \vdots \\ y_{n} \end{bmatrix} = \begin{bmatrix} x_1+y_{1} \\ x_2+y_{2} \\ \vdots \\ x_n+y_{n} \end{bmatrix}"} Inner product xTy=x1y1+x2y2+...+xnyn{"version":"1.1","math":"\textbf{x}^T \textbf{y} = x_1y_1 + x_2y_2+...+x_ny_n"} Magnitude of a vector How do we compute the magnitude of a vector or its length geometrically? length((x))=x12+x22+...+xn2{"version":"1.1","math":"\mathrm{length}(\textbf(x)) = \sqrt{x_1^2 + x_2^2 + ... + x_n^2}"} The above length is also called  2-norm of a vector. 