Topic 1 main points summarization    The explanation of an algorithm is gone through and shown to be viewed as a set of  instructions but for a computer to decipher    Machine learning is introduced and explained in brief terms how it works and why we use it, simply to decipher the volume of data that we cannot handle as humans and make it easier and more efficient.    1.5 shows how important machine learning can be and names many different ways machine learning is used in the real world such as being used in voice recognition, robotics and even beating world champions in board games.          1.6 shows us how machine learning works step by step when trying to make decisions about something. This includes data manipulation first, analyzing this data secondly and then evaluating and visualizing the data lastly. In 1.7 supervised learning is introduced to us and to my understanding is that datasets have information and relationships built into them from the start so that the algorithm knows from the beginning if an object has a certain attribute, etc. We are also shown that there are two types of supervised learning which is classification problems and regression problems. In 1.8 we are shown unsupervised learning which is basically the opposite of what was shown in 1.7. We are not given any built in relationships in the datasets and our machine algorithm has to create this by using clustering or factor analysis. In 1.9 we are shown reinforcement learning which is something I am familiar with, it is basically how humans learn and adapt to interacting in an environment by receiving evaluation and changing the thought pattern in the next decision. In 1.10 we go through model evaluation and are shown it is quite important to test many different datasets and models as we do not know which will be the best fit. Effective ways to approach this problem is to look at the averaged evaluation scores on lots of random test datasets and to use cross-validation. In 1.12 we are taught on why it is important to know the mathematical concepts behind machine learning and briefly shown what a vector is and how we can perform the three main operations. In 1.13 cosine similarity is shown to be a function in which we can use to find the similarity between two vectors in an inner product space where as cosine distance finds the dissimilarity in positive space. In 1.14 we are refreshed on matrices and go over all the basic operations such as addition/subtraction, multiplication, inverse, transposing and types of matrices.            1.15 shows the vector space model which is vital to retrieving information between vectors. Calculating the Euclidean distance will find the similarity between two documents within the vector space model.    1.16 and 1.17 talks about python and how to set it up which I have already done.   1.18 talks about all the different types of variables such as lists, tuples, dicts, strings and  integers.    1.19 goes over conditional statements such as if, elif and else. Also briefly goes over  indentation which is very important in relation to conditional statements and branching.   1.20 briefly goes over iterations/loops via the for and while statements and shows how we  can initialize lists using these tools    1.21 shows us functions which are essentially blocks of code that can be called so they can be used. We create them by using the keyword ‘def’ followed by the name of the function  and the argument that is used within the function. The function can either return a value or simply do something with the argument or change it. Anonymous functions are also shown to be functions but not bound to an identifier.    1.22 briefly goes over Python modules and packages which can be used to store functions  and be used and imported. We are taught how to do this via code and also all the packages we will use such as SciPy and matplotlib.    The text in 1.23 describes how we are able to use the numpy package to create and  manipulate vectors and matrices. There are many code examples to help us understand and play around with the ideas given.    1.24 shows how we are able to define, add and subtract matrices of similar dimensions using numpy also. In 1.25 this is similar to the previous module but this time we are taught how to now multiply matrices together whether they are of the same dimensions or share the same number with the rows and columns. In 1.26 we go over the division of matrices and inverting matrices as this is needed in order to divide matrices. It is shown that numpy can be easily used to invert matrices and now we are able to divide the matrices easily and output. In 1.27 we are shown how to access different elements of the numpy matrices and arrays, we can do this with slicing or logical checks as shown in the module.  